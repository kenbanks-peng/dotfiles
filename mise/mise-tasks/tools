#!/usr/bin/env nu
#MISE description="List miscellaneous tools"

# Package manager groups are displayed at the end, after custom groups
const PACKAGE_MANAGER_GROUPS = ["bun", "uv", "brew", "mise"]
const COMMAND_COLUMN_WIDTH = 22

# Helper to run an external command and parse its output, returning [] on failure
def run_command [cmd: closure, parser: closure] {
  try {
    let result = (do $cmd | complete)
    if $result.exit_code == 0 {
      do $parser $result.stdout
    } else {
      []
    }
  } catch {
    []
  }
}

def uv_tools [] {
  run_command { ^uv tool ls } {|stdout|
    $stdout
    | lines
    | where {|line| not ($line | str starts-with "-") and ($line | str trim | is-not-empty)}
    | each {|line|
        let parts = ($line | split row " ")
        let name = ($parts | get 0)
        {group: "uv" command: $name desc: "uv"}
      }
  }
}

def bun_tools [] {
  run_command { ^bun pm ls -g } {|stdout|
    $stdout
    | lines
    | skip 1
    | each {|line|
        let clean = ($line | str replace -r '^[└├─│ ]+' '')
        let name = ($clean | split row "@" | get 0)
        {group: "bun" command: $name desc: "bun"}
      }
  }
}

def brew_tools [] {
  run_command { ^brew leaves --installed-on-request } {|stdout|
    $stdout
    | lines
    | where {|line| $line | str trim | is-not-empty}
    | each {|line|
        # Extract just the formula name from tap paths like "tako8ki/tap/gobang"
        # Using `last` works for both "gobang" (returns "gobang") and "tako8ki/tap/gobang" (returns "gobang")
        let name = ($line | split row "/" | last)
        {group: "brew" command: $name desc: "brew"}
      }
  }
}

def mise_list [] {
  run_command { ^mise list } {|stdout|
    $stdout
    | lines
    | where {|line| $line | str trim | is-not-empty}
    | each {|line|
        let parts = ($line | split row -r '\s+')
        let full = ($parts | get 0)
        # Extract backend and package from "backend:package"
        # If no colon exists, backend gets the full string and package becomes empty
        let colon_parts = ($full | split row ":")
        let backend = ($colon_parts | get 0)
        let package = ($colon_parts | skip 1 | str join ":")
        # Extract command name (last segment after / or the whole package)
        # Using `last` works for both cases
        let name = ($package | split row "/" | last)
        {group: "mise" command: $name desc: $backend}
      }
  }
}

def tools_metadata [] {
  let script_dir = ($env.FILE_PWD? | default (pwd))
  open ($script_dir | path join "tools.nuon")
}

def mise_tasks [] {
  run_command { ^mise tasks ls } {|stdout|
    $stdout
    | lines
    | each {|line|
        let parts = ($line | split row -r '\s{2,}')
        let name = ($parts | get 0)
        let desc = ($parts | get -o 1 | default "")
        if ($name | str contains ":") {
          let name_parts = ($name | split row ":")
          {group: ($name_parts | get 0) command: ($name_parts | get 1) desc: $desc}
        } else {
          {group: "misc" command: $name desc: $desc}
        }
      }
  }
}

def format_row [row] {
  let command = ($row.command | fill -w $COMMAND_COLUMN_WIDTH)
  $"($command) (ansi grey)($row.desc)(ansi reset)"
}

def main [filter?: string] {
  let metadata = (tools_metadata)
  let uv = (uv_tools)
  let bun = (bun_tools)
  let brew = (brew_tools)
  let mise_installed = (mise_list)
  let mise = (mise_tasks)

  # Combine all available tools with their source
  # All records have consistent shape: command, source, and optional group/desc
  let available = ($uv | each {|t| {command: $t.command source: "uv" group: null desc: $t.desc}}
    | append ($bun | each {|t| {command: $t.command source: "bun" group: null desc: $t.desc}})
    | append ($brew | each {|t| {command: $t.command source: "brew" group: null desc: $t.desc}})
    | append ($mise_installed | each {|t| {command: $t.command source: "mise" group: null desc: $t.desc}})
    | append ($mise | each {|t| {command: $t.command source: "mise" group: $t.group desc: $t.desc}}))

  # Deduplicate by command name, preferring mise tasks (which have group/desc)
  let unique_commands = ($available | group-by command | transpose name tools | each {|t|
      let mise_tools = ($t.tools | where source == "mise")
      if ($mise_tools | is-not-empty) {
        $mise_tools | first
      } else {
        $t.tools | first
      }
    })

  # Enrich with metadata from tools.nuon
  # Match by name (cli) if present, otherwise by command (display name)
  # A single package can expand to multiple commands (e.g., poppler -> pdfattach, pdfdetach, etc.)
  # Tools with hide: true are excluded from output
  let enriched = ($unique_commands | each {|t|
      let meta_matches = ($metadata | where {|m| ($m.name? | default $m.command) == $t.command})
      if ($meta_matches | any {|m| $m.hide? == true}) {
        []
      } else if ($meta_matches | is-not-empty) {
        $meta_matches | each {|meta| {group: $meta.group command: $meta.command desc: $meta.desc}}
      } else if ($t.group? != null) {
        [{group: $t.group command: $t.command desc: ($t.desc? | default "")}]
      } else {
        [{group: $t.source command: $t.command desc: $t.source}]
      }
    } | flatten)

  # Add forced tools (force: true) that weren't discovered from package managers
  # Exclude tools with hide: true
  let enriched_commands = ($enriched | get command)
  let forced_tools = ($metadata
    | where {|m| $m.force? == true and $m.hide? != true and ($m.command not-in $enriched_commands)}
    | each {|m| {group: $m.group command: $m.command desc: $m.desc}})
  let final_tools = ($enriched | append $forced_tools)

  let filtered = if $filter == null {
    $final_tools
  } else {
    $final_tools | where group == $filter
  }

  if ($filtered | is-empty) {
    return
  }

  let all_groups = ($filtered | get group | uniq)
  let main_groups = ($all_groups | where {|g| $g not-in $PACKAGE_MANAGER_GROUPS} | sort)
  let end_groups = ($all_groups | where {|g| $g in $PACKAGE_MANAGER_GROUPS})
  let groups = ($main_groups | append $end_groups)

  $groups
  | each {|grp|
      let rows = ($filtered | where group == $grp | sort-by command)
      let header = $"(ansi green)($grp | str upcase)(ansi reset)"
      let items = ($rows | each {|r| format_row $r} | str join "\n")
      $"($header)\n($items)"
    }
  | str join "\n\n"
  | $in + "\n"
}
