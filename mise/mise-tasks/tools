#!/usr/bin/env nu
#MISE description="List miscellaneous tools"

def tools [] {
  [
    [group task desc];
    # PDF tools
    [pdf pdfattach "Attach PDFs"]
    [pdf pdfdetach "Detach PDFs"]
    [pdf pdftocairo "PDF to Cairo"]
    [pdf pdffonts "PDF fonts"]
    [pdf pdftohtml "PDF to HTML"]
    [pdf pdfimages "PDF to images"]
    [pdf pdfinfo "PDF info"]
    [pdf pdftoppm "PDF to ppm"]
    [pdf pdftops "PDF to ps"]
    [pdf pdfseparate "PDF separate"]
    [pdf pdfsig "PDF sig"]
    [pdf pdfunite "PDF unite"]
    [pdf pdftotext "PDF to text"]
    # Terminal multiplexers
    [terminal zellij "Zellij terminal"]
    [terminal tmux "tmux terminal"]
    # Git/Repo tools
    [repo gitui "gitui git tui"]
    [repo lazyjj "lazyjj"]
    [repo delta "git delta viewer"]
    [repo hub "simplified github cli"]
    # Database tools
    [db dblab "database tui"]
    [db gobang "database tui"]
    [db lazysql "lazysql"]
    [db sqlite3 "SQLite db cli"]
    [db sqld "lib sql"]
    [db tursodb "turso db"]
    # Container/VM tools
    [container lazydocker "lazydocker"]
    [container limactl "create linux vm"]
    # Linting tools
    [lint biome "lint: biome check --write"]
    [lint shellcheck "shell linter"]
    # File transfer tools
    [file portal "file transfer (portal) tui"]
    # Text/markdown tools
    [text glow "glow markdown viewer"]
    # JSON tools
    [json jq "jq json processing"]
    [json jqn "jq.node json processing"]
    [json yq "jq-like for yaml, json, xml, properties, csv and tsv"]
    [json jc "CLI output to json"]
    [json jid "json interactive digger"]
    [json fx "fx json viewer"]
    [json jnv "jnv json navigator"]
    # Web/HTTP tools
    [web hurl "curl test framework"]
    [web xh "curl alternative"]
    [web curlie "curl alternative"]
    [web posting "posting tui"]
    [web caddy "caddy web server"]
    # Dev tools (remaining)
    [dev sshs "ssh client tui"]
    [dev tokei "count lines of code"]
    [dev lunchy "launch services ~/Library/LaunchAgents/"]
    [dev nerdlog "log tui"]
    [dev watchexec "watch for changes"]
    [dev navi "Shell cheatsheet"]
    # Unix alternatives
    [unix ditto "copy alternative"]
    [unix sd "sed alternative for find/replace within files"]
    [unix sad "sed alternative with fzf"]
    [unix rg "ripgrep grep alternative"]
    [unix tldr "man alternative"]
    [unix bat "cat alternative"]
    [unix procs "ps alternative"]
    [unix btop "top tui"]
    [unix glances "top tui"]
    [unix macmon "resource monitor"]
    [unix tspin "tail alternative"]
    [unix choose "cut alternative"]
    [unix gping "ping alternative"]
    # Util tools
    [util gpg-tui "GPG tui"]
    [util sniffnet "Network monitor"]
    [util lazyjournal "lazyjournal"]
    [util sk "skim, an fzf alternative"]
    [util tv "an fzf alternative"]
    [util spark "Sparkline generator"]
  ]
}

def mise_tasks [] {
  ^mise tasks ls
  | lines
  | each {|line|
      let parts = ($line | split row -r '\s{2,}')
      let name = ($parts | get 0)
      let desc = ($parts | get -o 1 | default "")
      if ($name | str contains ":") {
        let name_parts = ($name | split row ":")
        {group: ($name_parts | get 0) task: ($name_parts | get 1) desc: $desc}
      } else {
        {group: "misc" task: $name desc: $desc}
      }
    }
}

def format_row [row] {
  let task = ($row.task | fill -w 22)
  $"($task) (ansi grey)($row.desc)(ansi reset)"
}

def main [filter?: string] {
  let all_data = (mise_tasks | append (tools))

  let filtered = if $filter == null {
    $all_data
  } else {
    $all_data | where group == $filter
  }

  if ($filtered | is-empty) {
    return
  }

  let groups = ($filtered | get group | uniq | sort)

  $groups
  | each {|grp|
      let rows = ($filtered | where group == $grp | sort-by task)
      let header = $"(ansi green)($grp | str upcase)(ansi reset)"
      let items = ($rows | each {|r| format_row $r} | str join "\n")
      $"($header)\n($items)"
    }
  | str join "\n\n"
}
