#!/usr/bin/env nu
#MISE description="List miscellaneous tools"

def uv_tools [] {
  try {
    ^uv tool ls
    | lines
    | where {|line| ($line | str starts-with "-") == false and ($line | str trim | is-not-empty)}
    | each {|line|
        let parts = ($line | split row " ")
        let name = ($parts | get 0)
        {group: "uv" task: $name desc: "uv"}
      }
  } catch {
    []
  }
}

def bun_tools [] {
  let result = (do { ^bun pm ls -g } | complete)
  if $result.exit_code == 0 {
    $result.stdout
    | lines
    | skip 1
    | each {|line|
        let clean = ($line | str replace -r '^[└├─│ ]+' '')
        let name = ($clean | split row "@" | get 0)
        {group: "bun" task: $name desc: "bun"}
      }
  } else {
    []
  }
}

def brew_tools [] {
  let result = (do { ^brew leaves --installed-on-request } | complete)
  if $result.exit_code == 0 {
    $result.stdout
    | lines
    | where {|line| $line | str trim | is-not-empty}
    | each {|name| {group: "brew" task: $name desc: "brew"}}
  } else {
    []
  }
}

def tools_metadata [] {
  let script_dir = ($env.FILE_PWD? | default (pwd))
  open ($script_dir | path join "tools.csv")
}

def mise_tasks [] {
  ^mise tasks ls
  | lines
  | each {|line|
      let parts = ($line | split row -r '\s{2,}')
      let name = ($parts | get 0)
      let desc = ($parts | get -o 1 | default "")
      if ($name | str contains ":") {
        let name_parts = ($name | split row ":")
        {group: ($name_parts | get 0) task: ($name_parts | get 1) desc: $desc}
      } else {
        {group: "misc" task: $name desc: $desc}
      }
    }
}

def format_row [row] {
  let task = ($row.task | fill -w 22)
  $"($task) (ansi grey)($row.desc)(ansi reset)"
}

def main [filter?: string] {
  let metadata = (tools_metadata)
  let uv = (uv_tools)
  let bun = (bun_tools)
  let brew = (brew_tools)
  let mise = (mise_tasks)

  # Combine all available tools with their source
  let available = ($uv | each {|t| {task: $t.task source: "uv"}}
    | append ($bun | each {|t| {task: $t.task source: "bun"}})
    | append ($brew | each {|t| {task: $t.task source: "brew"}})
    | append ($mise | each {|t| {task: $t.task source: "mise" group: $t.group desc: $t.desc}}))

  # Deduplicate by task name, preferring mise tasks (which have group/desc)
  let unique_tasks = ($available | group-by task | transpose name tools | each {|t|
      let mise_tools = ($t.tools | where source == "mise")
      if ($mise_tools | is-not-empty) {
        $mise_tools | first
      } else {
        $t.tools | first
      }
    })

  # Enrich with metadata from tools.csv
  let enriched = ($unique_tasks | each {|t|
      let meta_matches = ($metadata | where task == $t.task)
      if ($meta_matches | is-not-empty) {
        let meta = ($meta_matches | first)
        {group: $meta.group task: $t.task desc: $meta.desc}
      } else if ($t.group? != null) {
        {group: $t.group task: $t.task desc: ($t.desc? | default "")}
      } else {
        {group: $t.source task: $t.task desc: $t.source}
      }
    })

  let filtered = if $filter == null {
    $enriched
  } else {
    $enriched | where group == $filter
  }

  if ($filtered | is-empty) {
    return
  }

  let all_groups = ($filtered | get group | uniq)
  let main_groups = ($all_groups | where {|g| $g != "bun" and $g != "uv" and $g != "brew"} | sort)
  let end_groups = ($all_groups | where {|g| $g == "bun" or $g == "uv" or $g == "brew"})
  let groups = ($main_groups | append $end_groups)

  $groups
  | each {|grp|
      let rows = ($filtered | where group == $grp | sort-by task)
      let header = $"(ansi green)($grp | str upcase)(ansi reset)"
      let items = ($rows | each {|r| format_row $r} | str join "\n")
      $"($header)\n($items)"
    }
  | str join "\n\n"
  | $in + "\n"
}
